# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class JobOperations(object):
    """JobOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~ai_supercomputer_management_client.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def _create_or_update_initial(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        placement_policies,  # type: List["models.PlacementPolicy"]
        framework_image,  # type: "models.FrameworkImageBase"
        system_data=None,  # type: Optional["models.ResourceSystemData"]
        type=None,  # type: Optional[str]
        provisioning_state=None,  # type: Optional[Union[str, "models.ProvisioningState"]]
        scheduling_priority=None,  # type: Optional[Union[str, "models.SchedulingPriority"]]
        data_location=None,  # type: Optional[List["models.StorageLocation"]]
        code_location=None,  # type: Optional["models.StorageLocation"]
        output_location=None,  # type: Optional["models.StorageLocation"]
        group_policy_name=None,  # type: Optional[str]
        checkpoint_policy=None,  # type: Optional["models.CheckpointPolicy"]
        compilation_policy=None,  # type: Optional["models.CompilationPolicy"]
        deployment_policy=None,  # type: Optional["models.DeploymentPolicy"]
        max_job_execution_time=None,  # type: Optional[float]
        program=None,  # type: Optional[str]
        program_args=None,  # type: Optional[str]
        tensor_board_log_directory=None,  # type: Optional[str]
        status=None,  # type: Optional[Union[str, "models.JobStatus"]]
        description=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional["models.JobResourceDescription"]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["models.JobResourceDescription"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.JobResourceDescription(system_data=system_data, type_identity_type=type, provisioning_state=provisioning_state, placement_policies=placement_policies, scheduling_priority=scheduling_priority, data_location=data_location, code_location=code_location, output_location=output_location, framework_image=framework_image, group_policy_name=group_policy_name, checkpoint_policy=checkpoint_policy, compilation_policy=compilation_policy, deployment_policy=deployment_policy, max_job_execution_time=max_job_execution_time, program=program, program_args=program_args, tensor_board_log_directory=tensor_board_log_directory, status=status, description=description)
        api_version = "2020-12-01-preview"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self._create_or_update_initial.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', skip_quote=True),
            'accountName': self._serialize.url("account_name", account_name, 'str', skip_quote=True),
            'jobName': self._serialize.url("job_name", job_name, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'JobResourceDescription')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorModel, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JobResourceDescription', pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize('JobResourceDescription', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    _create_or_update_initial.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}'}  # type: ignore

    def begin_create_or_update(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        placement_policies,  # type: List["models.PlacementPolicy"]
        framework_image,  # type: "models.FrameworkImageBase"
        system_data=None,  # type: Optional["models.ResourceSystemData"]
        type=None,  # type: Optional[str]
        provisioning_state=None,  # type: Optional[Union[str, "models.ProvisioningState"]]
        scheduling_priority=None,  # type: Optional[Union[str, "models.SchedulingPriority"]]
        data_location=None,  # type: Optional[List["models.StorageLocation"]]
        code_location=None,  # type: Optional["models.StorageLocation"]
        output_location=None,  # type: Optional["models.StorageLocation"]
        group_policy_name=None,  # type: Optional[str]
        checkpoint_policy=None,  # type: Optional["models.CheckpointPolicy"]
        compilation_policy=None,  # type: Optional["models.CompilationPolicy"]
        deployment_policy=None,  # type: Optional["models.DeploymentPolicy"]
        max_job_execution_time=None,  # type: Optional[float]
        program=None,  # type: Optional[str]
        program_args=None,  # type: Optional[str]
        tensor_board_log_directory=None,  # type: Optional[str]
        status=None,  # type: Optional[Union[str, "models.JobStatus"]]
        description=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller["models.JobResourceDescription"]
        """Creates or updates a job resource.

        Creates a job resource with the specified name, description and properties. If a job with the
        same name exists, then it is updated with the specified description and properties.

        :param resource_group_name: The name of the resource group within the user's subscription.
        :type resource_group_name: str
        :param account_name: The name of the Singularity account.
        :type account_name: str
        :param job_name: The name of the Singularity job.
        :type job_name: str
        :param placement_policies: Collection of placement policies to use for the training job.
        :type placement_policies: list[~ai_supercomputer_management_client.models.PlacementPolicy]
        :param framework_image: Describes the framework for the job resource.
        :type framework_image: ~ai_supercomputer_management_client.models.FrameworkImageBase
        :param system_data:
        :type system_data: ~ai_supercomputer_management_client.models.ResourceSystemData
        :param type: The type of identity used for the resource. The type 'None' will remove any
         identities from the resource.
        :type type: str
        :param provisioning_state:
        :type provisioning_state: str or ~ai_supercomputer_management_client.models.ProvisioningState
        :param scheduling_priority:
        :type scheduling_priority: str or ~ai_supercomputer_management_client.models.SchedulingPriority
        :param data_location: Job input data location.
        :type data_location: list[~ai_supercomputer_management_client.models.StorageLocation]
        :param code_location: This type describes a storage location for jobs and services.
        :type code_location: ~ai_supercomputer_management_client.models.StorageLocation
        :param output_location: This type describes a storage location for jobs and services.
        :type output_location: ~ai_supercomputer_management_client.models.StorageLocation
        :param group_policy_name: Group policy name associated with the training job.
        :type group_policy_name: str
        :param checkpoint_policy: Describes the checkpointing policy for job.
        :type checkpoint_policy: ~ai_supercomputer_management_client.models.CheckpointPolicy
        :param compilation_policy: Describes the properties of compilation policy.
        :type compilation_policy: ~ai_supercomputer_management_client.models.CompilationPolicy
        :param deployment_policy: Describes the properties of deployment policy.
        :type deployment_policy: ~ai_supercomputer_management_client.models.DeploymentPolicy
        :param max_job_execution_time: Maximum execution time for a training job in the account (in
         hours).
        :type max_job_execution_time: float
        :param program: The entry script for your Job in the codeLocation. For interactive jobs,
         specify null.
        :type program: str
        :param program_args: Command line arguments to be passed to the program.
        :type program_args: str
        :param tensor_board_log_directory: The directory which TensorBoard will be configured to use as
         the log directory.
        :type tensor_board_log_directory: str
        :param status:
        :type status: str or ~ai_supercomputer_management_client.models.JobStatus
        :param description: User-friendly description of the job.
        :type description: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of LROPoller that returns either JobResourceDescription or the result of cls(response)
        :rtype: ~azure.core.polling.LROPoller[~ai_supercomputer_management_client.models.JobResourceDescription]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', True)  # type: Union[bool, PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType["models.JobResourceDescription"]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                account_name=account_name,
                job_name=job_name,
                placement_policies=placement_policies,
                framework_image=framework_image,
                system_data=system_data,
                type=type,
                provisioning_state=provisioning_state,
                scheduling_priority=scheduling_priority,
                data_location=data_location,
                code_location=code_location,
                output_location=output_location,
                group_policy_name=group_policy_name,
                checkpoint_policy=checkpoint_policy,
                compilation_policy=compilation_policy,
                deployment_policy=deployment_policy,
                max_job_execution_time=max_job_execution_time,
                program=program,
                program_args=program_args,
                tensor_board_log_directory=tensor_board_log_directory,
                status=status,
                description=description,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize('JobResourceDescription', pipeline_response)

            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True: polling_method = ARMPolling(lro_delay,  **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_create_or_update.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}'}  # type: ignore

    def _update_initial(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        system_data=None,  # type: Optional["models.ResourceSystemData"]
        description=None,  # type: Optional[str]
        scheduling_priority=None,  # type: Optional[Union[str, "models.SchedulingPriority"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional["models.JobResourceDescription"]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["models.JobResourceDescription"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.JobResourcePatchDescription(system_data=system_data, description=description, scheduling_priority=scheduling_priority)
        api_version = "2020-12-01-preview"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self._update_initial.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', skip_quote=True),
            'accountName': self._serialize.url("account_name", account_name, 'str', skip_quote=True),
            'jobName': self._serialize.url("job_name", job_name, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'JobResourcePatchDescription')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorModel, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('JobResourceDescription', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    _update_initial.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}'}  # type: ignore

    def begin_update(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        system_data=None,  # type: Optional["models.ResourceSystemData"]
        description=None,  # type: Optional[str]
        scheduling_priority=None,  # type: Optional[Union[str, "models.SchedulingPriority"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller["models.JobResourceDescription"]
        """Updates a job resource.

        Updates a job resource with the specified properties. If a job with the same name exists, then
        it is updated with the specified properties. If a job doesn't exist, then a no-content
        exception will be thrown.

        :param resource_group_name: The name of the resource group within the user's subscription.
        :type resource_group_name: str
        :param account_name: The name of the Singularity account.
        :type account_name: str
        :param job_name: The name of the Singularity job.
        :type job_name: str
        :param system_data:
        :type system_data: ~ai_supercomputer_management_client.models.ResourceSystemData
        :param description: User-friendly description of the job.
        :type description: str
        :param scheduling_priority:
        :type scheduling_priority: str or ~ai_supercomputer_management_client.models.SchedulingPriority
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of LROPoller that returns either JobResourceDescription or the result of cls(response)
        :rtype: ~azure.core.polling.LROPoller[~ai_supercomputer_management_client.models.JobResourceDescription]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', True)  # type: Union[bool, PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType["models.JobResourceDescription"]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                account_name=account_name,
                job_name=job_name,
                system_data=system_data,
                description=description,
                scheduling_priority=scheduling_priority,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize('JobResourceDescription', pipeline_response)

            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True: polling_method = ARMPolling(lro_delay,  **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_update.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}'}  # type: ignore

    def get(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.JobResourceDescription"
        """Gets the job resource with the given name.

        Gets the information about the job resource with the given name. The information include the
        description and other properties of the job.

        :param resource_group_name: The name of the resource group within the user's subscription.
        :type resource_group_name: str
        :param account_name: The name of the Singularity account.
        :type account_name: str
        :param job_name: The name of the Singularity job.
        :type job_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JobResourceDescription, or the result of cls(response)
        :rtype: ~ai_supercomputer_management_client.models.JobResourceDescription
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.JobResourceDescription"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-01-preview"

        # Construct URL
        url = self.get.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', skip_quote=True),
            'accountName': self._serialize.url("account_name", account_name, 'str', skip_quote=True),
            'jobName': self._serialize.url("job_name", job_name, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorModel, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('JobResourceDescription', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}'}  # type: ignore

    def _delete_initial(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-01-preview"

        # Construct URL
        url = self._delete_initial.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', skip_quote=True),
            'accountName': self._serialize.url("account_name", account_name, 'str', skip_quote=True),
            'jobName': self._serialize.url("job_name", job_name, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorModel, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    _delete_initial.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}'}  # type: ignore

    def begin_delete(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller[None]
        """Deletes the job resource.

        Deletes the job resource identified by the name.

        :param resource_group_name: The name of the resource group within the user's subscription.
        :type resource_group_name: str
        :param account_name: The name of the Singularity account.
        :type account_name: str
        :param job_name: The name of the Singularity job.
        :type job_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of LROPoller that returns either None or the result of cls(response)
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', True)  # type: Union[bool, PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._delete_initial(
                resource_group_name=resource_group_name,
                account_name=account_name,
                job_name=job_name,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True: polling_method = ARMPolling(lro_delay,  **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_delete.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}'}  # type: ignore

    def _approve_initial(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        group_policy_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.JobUserActionDescription(group_policy_name=group_policy_name)
        api_version = "2020-12-01-preview"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self._approve_initial.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', skip_quote=True),
            'accountName': self._serialize.url("account_name", account_name, 'str', skip_quote=True),
            'jobName': self._serialize.url("job_name", job_name, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if _body is not None:
            body_content = self._serialize.body(_body, 'JobUserActionDescription')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorModel, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    _approve_initial.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}/approve'}  # type: ignore

    def begin_approve(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        group_policy_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller[None]
        """Admin Quota approval for Job.

        This action can be used by the account admin to approve a job manually, which is otherwise
        blocked by insufficient user-level quota (represented by Group Policy).

        :param resource_group_name: The name of the resource group within the user's subscription.
        :type resource_group_name: str
        :param account_name: The name of the Singularity account.
        :type account_name: str
        :param job_name: The name of the Singularity job.
        :type job_name: str
        :param group_policy_name: The name of the group policy.
        :type group_policy_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of LROPoller that returns either None or the result of cls(response)
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', True)  # type: Union[bool, PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._approve_initial(
                resource_group_name=resource_group_name,
                account_name=account_name,
                job_name=job_name,
                group_policy_name=group_policy_name,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True: polling_method = ARMPolling(lro_delay,  **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_approve.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}/approve'}  # type: ignore

    def _create_sas_token_initial(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        start_time=None,  # type: Optional[datetime.datetime]
        expiration_time=None,  # type: Optional[datetime.datetime]
        protocol=None,  # type: Optional[Union[str, "models.ProtocolType"]]
        group_policy_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.JobSasTokenDescription"
        cls = kwargs.pop('cls', None)  # type: ClsType["models.JobSasTokenDescription"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.JobSasTokenDescription(start_time=start_time, expiration_time=expiration_time, protocol=protocol, group_policy_name=group_policy_name)
        api_version = "2020-12-01-preview"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self._create_sas_token_initial.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', skip_quote=True),
            'accountName': self._serialize.url("account_name", account_name, 'str', skip_quote=True),
            'jobName': self._serialize.url("job_name", job_name, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        if _body is not None:
            body_content = self._serialize.body(_body, 'JobSasTokenDescription')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorModel, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if response.status_code == 200:
            deserialized = self._deserialize('JobSasTokenDescription', pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize('JobSasTokenDescription', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    _create_sas_token_initial.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}/createsastoken'}  # type: ignore

    def begin_create_sas_token(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        start_time=None,  # type: Optional[datetime.datetime]
        expiration_time=None,  # type: Optional[datetime.datetime]
        protocol=None,  # type: Optional[Union[str, "models.ProtocolType"]]
        group_policy_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller["models.JobSasTokenDescription"]
        """Creates SAS token to access job resource.

        Creates a Shared Access Signature (SAS) token, that can be used for accessing job resource with
        the protocol specified in the description.

        :param resource_group_name: The name of the resource group within the user's subscription.
        :type resource_group_name: str
        :param account_name: The name of the Singularity account.
        :type account_name: str
        :param job_name: The name of the Singularity job.
        :type job_name: str
        :param start_time: The SAS token is valid only after the start time (UTC).
        :type start_time: ~datetime.datetime
        :param expiration_time: The time (UTC) after which the SAS token becomes invalid.
        :type expiration_time: ~datetime.datetime
        :param protocol:
        :type protocol: str or ~ai_supercomputer_management_client.models.ProtocolType
        :param group_policy_name: The name of the group policy.
        :type group_policy_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of LROPoller that returns either JobSasTokenDescription or the result of cls(response)
        :rtype: ~azure.core.polling.LROPoller[~ai_supercomputer_management_client.models.JobSasTokenDescription]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', True)  # type: Union[bool, PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType["models.JobSasTokenDescription"]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_sas_token_initial(
                resource_group_name=resource_group_name,
                account_name=account_name,
                job_name=job_name,
                start_time=start_time,
                expiration_time=expiration_time,
                protocol=protocol,
                group_policy_name=group_policy_name,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize('JobSasTokenDescription', pipeline_response)

            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True: polling_method = ARMPolling(lro_delay,  **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_create_sas_token.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}/createsastoken'}  # type: ignore

    def renew_key(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.JobSasTokenDescription"
        """Renews to the signing key for the job.

        Renews to the Shared Access Signature (SAS) token singining key for the job. It invalidates all
        tokens generated prior to key rotation.

        :param resource_group_name: The name of the resource group within the user's subscription.
        :type resource_group_name: str
        :param account_name: The name of the Singularity account.
        :type account_name: str
        :param job_name: The name of the Singularity job.
        :type job_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JobSasTokenDescription, or the result of cls(response)
        :rtype: ~ai_supercomputer_management_client.models.JobSasTokenDescription
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.JobSasTokenDescription"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-01-preview"

        # Construct URL
        url = self.renew_key.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', skip_quote=True),
            'accountName': self._serialize.url("account_name", account_name, 'str', skip_quote=True),
            'jobName': self._serialize.url("job_name", job_name, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorModel, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if response.status_code == 200:
            deserialized = self._deserialize('JobSasTokenDescription', pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize('JobSasTokenDescription', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    renew_key.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}/renewkey'}  # type: ignore

    def _suspend_initial(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        group_policy_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.JobUserActionDescription(group_policy_name=group_policy_name)
        api_version = "2020-12-01-preview"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self._suspend_initial.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', skip_quote=True),
            'accountName': self._serialize.url("account_name", account_name, 'str', skip_quote=True),
            'jobName': self._serialize.url("job_name", job_name, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if _body is not None:
            body_content = self._serialize.body(_body, 'JobUserActionDescription')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorModel, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    _suspend_initial.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}/suspend'}  # type: ignore

    def begin_suspend(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        group_policy_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller[None]
        """Suspends the running job.

        Suspending a job will stop the current execution and release any resources and quota
        reservations. The job will remain in the Suspended state until resumed or deleted.

        :param resource_group_name: The name of the resource group within the user's subscription.
        :type resource_group_name: str
        :param account_name: The name of the Singularity account.
        :type account_name: str
        :param job_name: The name of the Singularity job.
        :type job_name: str
        :param group_policy_name: The name of the group policy.
        :type group_policy_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of LROPoller that returns either None or the result of cls(response)
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', True)  # type: Union[bool, PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._suspend_initial(
                resource_group_name=resource_group_name,
                account_name=account_name,
                job_name=job_name,
                group_policy_name=group_policy_name,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True: polling_method = ARMPolling(lro_delay,  **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_suspend.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}/suspend'}  # type: ignore

    def _resume_initial(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        group_policy_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.JobUserActionDescription(group_policy_name=group_policy_name)
        api_version = "2020-12-01-preview"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self._resume_initial.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', skip_quote=True),
            'accountName': self._serialize.url("account_name", account_name, 'str', skip_quote=True),
            'jobName': self._serialize.url("job_name", job_name, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if _body is not None:
            body_content = self._serialize.body(_body, 'JobUserActionDescription')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorModel, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    _resume_initial.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}/resume'}  # type: ignore

    def begin_resume(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        group_policy_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller[None]
        """Resumes the paused job.

        Resuming a paused job will attempt to return the job into the running state by reserving quota
        and scheduling execution.

        :param resource_group_name: The name of the resource group within the user's subscription.
        :type resource_group_name: str
        :param account_name: The name of the Singularity account.
        :type account_name: str
        :param job_name: The name of the Singularity job.
        :type job_name: str
        :param group_policy_name: The name of the group policy.
        :type group_policy_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of LROPoller that returns either None or the result of cls(response)
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', True)  # type: Union[bool, PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._resume_initial(
                resource_group_name=resource_group_name,
                account_name=account_name,
                job_name=job_name,
                group_policy_name=group_policy_name,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True: polling_method = ARMPolling(lro_delay,  **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_resume.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}/resume'}  # type: ignore

    def list_by_account(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.JobResourceDescriptionList"]
        """Gets all the job resources in a given account.

        Gets the information about all the job resources in a given account. The information include
        the description and other properties of the job.

        :param resource_group_name: The name of the resource group within the user's subscription.
        :type resource_group_name: str
        :param account_name: The name of the Singularity account.
        :type account_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either JobResourceDescriptionList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~ai_supercomputer_management_client.models.JobResourceDescriptionList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.JobResourceDescriptionList"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-01-preview"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_by_account.metadata['url']  # type: ignore
                path_format_arguments = {
                    'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
                    'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', skip_quote=True),
                    'accountName': self._serialize.url("account_name", account_name, 'str', skip_quote=True),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('JobResourceDescriptionList', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.ErrorModel, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_by_account.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs'}  # type: ignore

    def _remove_initial(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        group_policy_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.JobUserActionDescription(group_policy_name=group_policy_name)
        api_version = "2020-12-01-preview"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self._remove_initial.metadata['url']  # type: ignore
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', skip_quote=True),
            'accountName': self._serialize.url("account_name", account_name, 'str', skip_quote=True),
            'jobName': self._serialize.url("job_name", job_name, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if _body is not None:
            body_content = self._serialize.body(_body, 'JobUserActionDescription')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorModel, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    _remove_initial.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}/remove'}  # type: ignore

    def begin_remove(
        self,
        resource_group_name,  # type: str
        account_name,  # type: str
        job_name,  # type: str
        group_policy_name=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> LROPoller[None]
        """Delete the job resource through remove action.

        Remove job operation is used to delete a job that is associated with a group policy.

        :param resource_group_name: The name of the resource group within the user's subscription.
        :type resource_group_name: str
        :param account_name: The name of the Singularity account.
        :type account_name: str
        :param job_name: The name of the Singularity job.
        :type job_name: str
        :param group_policy_name: The name of the group policy.
        :type group_policy_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: True for ARMPolling, False for no polling, or a
         polling object for personal polling strategy
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of LROPoller that returns either None or the result of cls(response)
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', True)  # type: Union[bool, PollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._remove_initial(
                resource_group_name=resource_group_name,
                account_name=account_name,
                job_name=job_name,
                group_policy_name=group_policy_name,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True: polling_method = ARMPolling(lro_delay,  **kwargs)
        elif polling is False: polling_method = NoPolling()
        else: polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_remove.metadata = {'url': '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.AISupercomputer/accounts/{accountName}/jobs/{jobName}/remove'}  # type: ignore
